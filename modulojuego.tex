\section{Módulo Juego}

%TODO descripcion

\begin{Interfaz}

  \textbf{usa}: \tadNombre{Mapa, Coordenada}.

  \textbf{se explica con}: \tadNombre{Juego}.

  \textbf{géneros}: \TipoVariable{juego}.

  \InterfazFuncion{CrearJuego}{\In{m}{mapa}}{juego}%
  [true]
  {$res$ \igobs crearJuego($m_0$) $\land$ mapa($res$) \igobs $m_0$}
  [$\Theta(MUCHO)$]
  [Crea el nuevo juego, revisar la complejidad]

  \InterfazFuncion{AgregarPokemon}{\Inout{j}{juego}, \In{c}{coor}, \In{p}{pokemon}}{itPokemon}
  [$j \igobs j_0 \land puedoAgregarPokemon(c, j_0)$]
  {$j \igobs agregarPokemon(p, c, j_0)$}
  [$O(|P| + EC * log(EC))$]
  [EC es la maxima cantidad de jugadores esperando para atrapar un pokemon. |P| es el nombre mas largo para un pokemon en el juego]

  \InterfazFuncion{AgregarJugador}{\Inout{j}{juego}}{Nat}
  [$j \igobs j_0$]
  {$j \igobs agregarJugador(j_0) \land res = \#jugadores(j_0) + \#expulsados(j_0)$}
  [$O(J)$]
  [Agrega el jugador en el conjLineal, el iterador que devuelve el agregar se guarda en un vector donde la posicion es el id del jugador que voy a devolver]
  
  \InterfazFuncion{Conectarse}{\Inout{j}{juego}, \In{id}{Nat}, \In{c}{coor}}{}
  [$j \igobs j_0 \land id \in jugadores(j_0) \yluego \neg estaConectado(id, j_0) \land posExistente(c, mapa(j_0))$]
  {$j \igobs conectarse(id, c, j_0)$}
  [$O(log(EC))$]
  [Conecta al jugador pasado por parametro en la coordenada indicada]
  
  \InterfazFuncion{Desconectarse}{\Inout{j}{juego}, \In{id}{Nat}}{}
  [$j \igobs j_0 \land id \in jugadores(j_0) \yluego estaConectado(id, j_0)$]
  {$j \igobs desconectarse(id, j_0)$}
  [$O(log(EC))$]
  [Desconecta al jugador pasado por parametro]
  
  \InterfazFuncion{Moverse}{\Inout{j}{juego}, \In{id}{Nat}, \In{c}{coor}}{}
  [$j \igobs j_0 \land id \in jugadores(j_0) \yluego estaConectado(id, j_0) \land posExistente(c, mapa(j_0))$]
  {$j \igobs moverse(c, id, j_0)$}
  [$O((PS + PC) * |P| + log(EC))$]
  [Mueve al jugador pasado por parametro a la coordenada indicada]

  \InterfazFuncion{Mapa}{\In{j}{juego}}{Mapa}
  [true]
  {$res \igobs mapa(j)$}
  [$O(copy(mapa(j)))$]
  [Devuelve el mapa del juego]

  \InterfazFuncion{Jugadores}{\In{j}{juego}}{itConj(Jugador)}
  [true]
  {$res \igobs jugadores(j)$}
  [$\Theta(1)$]
  [Devuelve un iterador al conjunto de jugadores del juego]

  \InterfazFuncion{Jugadores}{\In{j}{juego}}{itConj(Jugador)}
  [true]
  {$res \igobs jugadores(j)$}
  [$\Theta(1)$]
  [Devuelve un iterador al conjunto de jugadores del juego]

  \InterfazFuncion{estaConectado}{\In{j}{juego}, \In{id}{Nat}}{Bool}
  [id $\in$ jugadores(j)]
  {$res \igobs estaConetado(id,j)$}
  [$\Theta(1)$]
  [Devuelve si el jugador con id ingresado esta conectado o no]

  \InterfazFuncion{posicion}{\In{j}{juego}, \In{id}{Nat}}{coor}
  [id $\in$ jugadores(j) $\yluego$ estaConectado(id,j)]
  {$res \igobs posicion(id,j)$}
  [$\Theta(1)$]
  [Devuelve la posicion actual del jugador con id ingresado si esta conectado]

  \InterfazFuncion{pokemones}{\In{j}{juego}, \In{id}{Nat}}{itLista(puntero(pokemon))} %%Para borrar todos los pokemones a la hora de eliminar al jugador tenemos complejidad lineal, pero hace falta una estructura que admita repetidos ya que lo que devuelve es un multiconjunto, no queremos hacer un modulo multiconjunto queremos ser felices. Después debatimos
  [id $\in$ jugadores(j)]
  {$res \igobs pokemons(id,j)$}
  [$\Theta(1)$]
  [Devuelve un iterador a la estructura que almacena los punteros a pokemons del jugador del id ingresado]
  
  \InterfazFuncion{expulsados}{\In{j}{juego}}{itConj(Jugador)}
  [True]
  {$res \igobs expulsados(j)$}
  [$\Theta(1)$]
  [Devuelve un iterador al conjunto de jugadores expulsados del juego]

  \InterfazFuncion{expulsados}{\In{j}{juego}}{itConj(Jugador)}
  [True]
  {$res \igobs expulsados(j)$}
  [$\Theta(1)$]
  [Devuelve un iterador al conjunto de jugadores expulsados del juego]

  \InterfazFuncion{posConPokemones}{\In{j}{juego}}{itConj(Coor)}
  [True]
  {$res \igobs posConPokemons(j)$}
  [$O(1)$]
  [Devuelve un iterador al conjunto de coordenadas en donde hay pokemons]

  \InterfazFuncion{pokemonEnPos}{\In{j}{juego}, \In{c}{Coor}}{itPokemon}
  [c $\in$ posConPokemons(j)]
  {$res \igobs pokemonEnPos(c,j)$}
  [$\Theta(1)$] %Pero podemos tomarlos lo que queramos
  [Devuelve un iterador al pokemon de la coordenada dada]

  \InterfazFuncion{cantMovimientosParaCaptura}{\In{j}{juego}, \In{c}{Coor}}{Nat}
  [c $\in$ posConPokemons(j)]
  {$res \igobs cantMovimientosParaCaptura(c,j)$}
  [$\Theta(1)$] %Pero podemos tomarnos lo que queramos (?) no, enrealidad no.
  [Devuelve la cantidad de movimientos acumulados hasta el momento, para atrapar al pokemon de la coordenada dada]

  \InterfazFuncion{puedoAgregarPokemon}{\In{j}{juego}, \In{c}{Coor}}{Bool}
  [True]
  {$res \igobs puedoAgregarPokemon(c,j)$}
  [$\Theta(???)$] 
  [Devuelve si la coordenada ingresada es válida para agregar un pokemon en ella]

  \InterfazFuncion{hayPokemonCercano}{\In{j}{juego}, \In{c}{Coor}}{Bool}
  [True]
  {$res \igobs hayPokemonCercano(c,j)$}
  [$\Theta(???)$] 
  [Devuelve si la coordenada ingresada pertenece al rango de un pokemon salvaje]   

  \InterfazFuncion{posPokemonCercano}{\In{j}{juego}, \In{c}{Coor}}{Coor}
  [$hayPokemonCercano(c,j)$]
  {$res \igobs posPokemonCercano(c,j)$}
  [$\Theta(???)$] %Todas estas ultimas deberian ser O(1) gracias al magico DiccAcHashMagicTableListTupl pero por las dudas dejemo' la incognita hasta que sea oficial
  [Devuelve la coordenada mas del pokemon salvaje del rango siempre y cuando haya uno]   

  \InterfazFuncion{entrenadoresPosibles}{\In{j}{juego}, \In{c}{Coor}}{itColaPrior(itJugador)}
  [$hayPokemonCercano(c,j) \yluego pokemonEnPos(posPokemonCercano(c,j),j).jugadoresEnRango \subseteq jugadoresConectados(c,j)$]
  {$res \igobs entrenadoresPosibles(c,pokemonEnPos(posPokemonCercano(c,j),j).jugadoresEnRango,j)$}
  [$\Theta(???)$] 
  [Devuelve un iterador a los jugadores que están esperando para atrapar al pokemon mas cercano a la coordenada ingresada]   

  \InterfazFuncion{indiceRareza}{\In{j}{juego}, \In{p}{Pokemon}}{Nat}
  [$p \in todosLosPokemons(j)$]
  {$res \igobs indiceRareza(p,j)$}
  [$\Theta(???)$] 
  [Devuelve el índice de rareza del pokemon del juego ingresado]

  \InterfazFuncion{indiceRareza}{\In{j}{juego}, \In{p}{Pokemon}}{Nat}
  [$p \in todosLosPokemons(j)$]
  {$res \igobs indiceRareza(p,j)$}
  [$\Theta(???)$] 
  [Devuelve el índice de rareza del pokemon del juego ingresado]

  \InterfazFuncion{cantPokemonesTotales}{\In{j}{juego}}{Nat}
  [true]
  {$res \igobs cantPokemonsTotales(p)$}
  [$\Theta(???)$] 
  [Devuelve la cantidad de pokemones que hay en el juego]

  \InterfazFuncion{cantMismaEspecie}{\In{j}{juego}, \In{p}{Pokemon}}{Nat}
  [true]
  {$res \igobs cantMismaEspecie(p, pokemons(j), j$}
  [$\Theta(???)$] 
  [Devuelve la cantidad de pokemones de la especie ingresada hay en el juego]

  
\end{Interfaz}

\begin{Representacion}
	\begin{Estructura}{Juego}[estr]
		\begin{Tupla}[estr]
			\tupItem{pokemones}{diccString}%
			\tupItem{jugadores}{conjLineal(jugador)}
			\tupItem{expulsados}{conjLineal(jugador)}
			\tupItem{jugadoresPorID}{Vector(itConj(jugador))}
			\tupItem{pokemonesPorPosicion}{DiccAc(coor,itDiccString(pokemon))}
			\tupItem{mapa}{Mapa}
			\tupItem{pT}{Nat}
		\end{Tupla}
	\end{Estructura}
	
	\begin{Estructura}{Jugador}[jug]
		\begin{Tupla}[jug]
			\tupItem{id}{Nat}%
			\tupItem{posicion}{Coordenada}
			\tupItem{estaConectado}{Bool}
			\tupItem{sanciones}{Nat}
			\tupItem{pokeCapturados}{ConjLineal(itDiccString(pokemon))}
		\end{Tupla}
	\end{Estructura}
	
	\begin{Estructura}{Pokemon}[poke]
		\begin{Tupla}[poke]
			\tupItem{tipo}{String}%
			\tupItem{contador}{Nat}
			\tupItem{jugadoresEnRango}{diccHeap}
			\tupItem{salvaje}{Bool}
		\end{Tupla}
	\end{Estructura}
\end{Representacion}

%%% Sanciones	O(1)
%%% Contador	O(1)
%%% Heap		O(log(EC))
%%% Atrapar		O(PS + PC)
%%% BorrarJ		O(|P| * PC)


 Rep: estr -$>$ bool
 \\
 1) La suma de toos los significados de pokemons es igual al PT
 \\
 2) Todos las posiciones de jugPorPosicion esta contenida en el heap
 \\
 3) Idem pokePorPosicion
 \\
 4) Todo jugador que esta conectado y no expulsado, existe en jugPorPosicion
 \\
 5) Para cada posicion hay un jugador en jugPorPosicion que pertenece a jugadores
 \\
 6) Para cada pos en pokePorPosicion hay pokemon en pokemones
 \\
 7) Para cada posicion en jugadoresEnRango, sus jugadores estan contenidos en jugadores
 \\
 8) Para cada jugador en jugadores: si no esta expulsado, sus pokemones estan contenidos en pokemones del juego y no estan en pokemonesPorPosicion; y si esta conectado, su posicion pertenece al mapa del juego
 \\
 9) Para cada pokemon en pokemones, si es salvaje: su contador es menor a 10, su posicion pertenece al mapa del juego y pertenece a pokemonEnPosicion
 

 Abs(e): estre - $>$ Jugo {Rep(e)} 
 pGo: Juego tq e.mapa = mapa(pGo) y e.jugadores = jugadores(pGo) yluego \\
 (Para todo j : jugador) j pertenece e.jugadores impluego 
 \\ j.sanciones = sanciones(j, pGo) ((j pertenece expulsados(pGo) y j.sanciones >= 10)\\
 oluego (j.pokesCapturados = pokemones(j,pGo) y j.estaConectado = estaConectad(j,pGo) \\
 y j.estaConectado impluego j.pos = posicion(j,pGo))) y \\
 (Para todo p : pokemon) p pertenece c.pokemones impluego (Para todo j : Jugador) \\
 j pertenece e.jugadores yluego p pertenece pokemones(j,pGo) o [(Para todo c : coord)\\
 c pertenece e.mapa.coordenadas yluego p = pokemonEnPos(c,pGo) y cantMovParaCap(c,pGo)\\
 p.contador]
 



%
%  \InterfazFuncion{Tope}{\In{p}{pila($\alpha$)}}{$\alpha$}
%  [$\lnot$vacía?($p$)]
%  {alias($res$ \igobs tope($p$))}
%  [$\Theta(1)$]
%  [devuelve el tope de la pila.]
%  [$res$ es modificable si y sólo si $p$ es modificable.]
%
%  \InterfazFuncion{Desapilar}{\Inout{p}{pila($\alpha$)}}{}
%  [$p \igobs p_0$ $\land$ $\lnot$vacía?($p$)]
%  {$p$ \igobs desapilar($p_0$) $\land$ $res$ \igobs tope($p$)}
%  [$\Theta(1)$]
%  [desapila el tope de $p$.]
%
%  \InterfazFuncion{Tamaño}{\In{p}{pila($\alpha$)}}{nat}
%  {$res$ \igobs tamaño($p$)}
%  [$\Theta(1)$]
%  [devuelve la cantidad de elementos apilados en $p$.]
%
