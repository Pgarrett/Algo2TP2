\section{Módulo Juego}

%TODO descripcion

\begin{Interfaz}

  \textbf{usa}: \tadNombre{Mapa, Coordenada}.

  \textbf{se explica con}: \tadNombre{Juego}.

  \textbf{géneros}: \TipoVariable{juego}.

  \InterfazFuncion{CrearJuego}{\In{m}{mapa}}{juego}%
  [$m = m_0$]
  {$res$ \igobs crearJuego($m_0$) $\land$ mapa($res$) \igobs $m_0$}

  \InterfazFuncion{AgregarPokemon}{\Inout{j}{juego}, \In{c}{coordenada}, \In{p}{pokemon}}{pokemon}
  [$j \igobs j_0$]
  {$j \igobs agregarPokemon(res$, c, j_0$)$}
  [$\Theta(|p| + EC * log(EC))$]

  \InterfazFuncion{AgregarJugador}{\Inout{j}{juego}}{jugador}
  [$j \igobs j_0$]
  {$j$ \igobs agregarJugador($res, j_0$)  \land  \neg estaConectado($j, res$)  \land  \neg vacio?($pokemons(j, res$)}
  [$\Theta(J)$]
\end{Interfaz}

\begin{Representacion}
	\begin{Estructura}{Juego}[estr]
		\begin{Tupla}[estr]
			\tupItem{pokemones}{diccTrie}%
			\tupItem{jugadores}{conjLineal}
			\tupItem{jugadoresPorPosicion}{conjHash}
			\tupItem{pokemonesPorPosicion}{conjHash}
			\tupItem{jugadoresEnRango}{diccHeap}
			\tupItem{mapa}{Mapa}
			\tupItem{pT}{Nat}
		\end{Tupla}
	\end{Estructura}
\end{Representacion}

%%% Sanciones	O(1)
%%% Contador	O(1)
%%% Heap		O(log(EC))
%%% Atrapar		O(PS + PC)
%%% BorrarJ		O(|P| * PC)


%
%  \InterfazFuncion{Tope}{\In{p}{pila($\alpha$)}}{$\alpha$}
%  [$\lnot$vacía?($p$)]
%  {alias($res$ \igobs tope($p$))}
%  [$\Theta(1)$]
%  [devuelve el tope de la pila.]
%  [$res$ es modificable si y sólo si $p$ es modificable.]
%
%  \InterfazFuncion{Desapilar}{\Inout{p}{pila($\alpha$)}}{}
%  [$p \igobs p_0$ $\land$ $\lnot$vacía?($p$)]
%  {$p$ \igobs desapilar($p_0$) $\land$ $res$ \igobs tope($p$)}
%  [$\Theta(1)$]
%  [desapila el tope de $p$.]
%
%  \InterfazFuncion{Tamaño}{\In{p}{pila($\alpha$)}}{nat}
%  {$res$ \igobs tamaño($p$)}
%  [$\Theta(1)$]
%  [devuelve la cantidad de elementos apilados en $p$.]
%
