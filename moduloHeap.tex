\section{Módulo Cola de mínima prioridad($\alpha$)}

El módulo cola de mínima prioridad consiste en una cola de prioridad de
elementos del tipo $\alpha$ cuya prioridad está determinada por un $nat$ de forma
tal que el elemento que se ingrese con el menor $nat$ será el de mayor prioridad.

\subsection{Especificación}

	\begin{tad}{\tadNombre{Cola de mínima prioridad($\alpha$)}}
	\tadIgualdadObservacional{c}{c'}{colaMinPrior($\alpha$)}{vacía?($c$) $\igobs$ vacía?($c'$) $\yluego$ \\
							($\neg$vacía?($c$) $\impluego$ (próximo($c$) $\igobs$ próximo($c'$) $\land$ \\
							\phantom{($\neg$vacía?($c$) $\impluego$ (}desencolar($c$) $\igobs$ desencolar($c'$))}

	\tadParametrosFormales{
		\tadEncabezadoInline{géneros}{$\alpha$}\\
		\tadEncabezadoInline{operaciones}{
			\tadOperacionInline{\argumento $<$ \argumento}{$\alpha$, $\alpha$}{bool} \hfill Relación de orden total estricto\footnotemark
		}
	}

	\footnotetext{\noindent Una relación es un orden total estricto cuando se cumple:
	\begin{description}
	 \item[Antirreflexividad:] $\neg$ $a < a$ para todo $a: \alpha$
	 \item[Antisimetría:] $(a < b \implies \neg\ b < a)$ para todo $a, b: \alpha$, $a \neq b$
	 \item[Transitividad:] $((a < b \land b < c) \implies a < c)$ para todo $a, b, c: \alpha$
	 \item[Totalidad:] $(a < b \lor b < a)$ para todo $a, b: \alpha$
	\end{description}
	}

	\tadGeneros{colaMinPrior($\alpha$)}
	\tadExporta{colaMinPrior($\alpha$), generadores, observadores}
	\tadUsa{\tadNombre{Bool}}

	\tadAlinearFunciones{desencolar}{$\alpha$,colaMinPrior($\alpha$)}

	\tadObservadores
	\tadOperacion{vacía?}{colaMinPrior($\alpha$)}{bool}{}
	\tadOperacion{próximo}{colaMinPrior($\alpha$)/c}{$\alpha$}{$\neg$ vacía?($c$)}
	\tadOperacion{desencolar}{colaMinPrior($\alpha$)/c}{colaMinPrior($\alpha$)}{$\neg$ vacía?($c$)}

	\tadGeneradores
	\tadOperacion{vacía}{}{colaMinPrior($\alpha$)}{}
	\tadOperacion{encolar}{$\alpha$,colaMinPrior($\alpha$)}{colaMinPrior($\alpha$)}{}

	\tadOtrasOperaciones
	\tadOperacion{tamaño}{colaMinPrior($\alpha$)}{nat}{}

	\tadAxiomas[\paratodo{colaMinPrior($\alpha$)}{c}, \paratodo{$\alpha$}{e}]
	\tadAlinearAxiomas{desencolar(encolar($e$, $c$))}{}

	\tadAxioma{vacía?(vacía)}{true}
	\tadAxioma{vacía?(encolar($e$, $c$))}{false}

	\tadAxioma{próximo(encolar($e$, $c$))}{\IF vacía?($c$) $\oluego$\ proximo($c$) $> e$ THEN $e$ ELSE próximo($c$) FI}

	\tadAxioma{desencolar(encolar($e$, $c$))}{\IF vacía?($c$) $\oluego$\ proximo($c$) $> e$ THEN $c$ ELSE encolar($e$, desencolar($c$)) FI}

	\end{tad}

\subsection{Interfaz}
	\tadParametrosFormales{
		\tadEncabezadoInline{géneros}{$\alpha$}
	}

	\textbf{se explica con}: \tadNombre{Cola de mínima prioridad(nat)}.

	\textbf{géneros}: \TipoVariable{colaMin($\alpha$)}.

\subsubsection{Operaciones básicas de Cola de mínima prioridad}

	\InterfazFuncion{Vacía}{}{colaMin($\alpha$)}
	[true]
	{$res$ $\igobs$ vacía}
	[O(1)]
	[Crea una cola de prioridad vacía]

	~

	\InterfazFuncion{Vacía?}{\In{c}{colaMin($\alpha$)}}{bool}
	[true]
	{$res$ $\igobs$ vacía?(c)}
	[O(1)]
	[Devuelve \TipoVariable{true} si y sólo si la cola está vacía]

	~

	\InterfazFuncion{Próximo}{\In{c}{colaMin($\alpha$)}}{$\alpha$}
	[$\neg$vacía?($c$)]
	{alias($res$ $\igobs$ próximo($c$))}
	[O(1)]
	[Devuelve el próximo elemento a desencolar]
	[$res$ es modificable si y sólo si $c$ es modificable]

	~

	\InterfazFuncion{Desencolar}{\Inout{c}{colaMin($\alpha$)}}{}
	[$\neg$vacía?($c$) $\land$ $c$ $\igobs$ $c_0$]
	{$c$ $\igobs$ desencolar($c_0$)}
	[O(log(tamaño(c)))]
	[Quita el elemento más prioritario]

	~

	\InterfazFuncion{Encolar}{\Inout{c}{colaMinPrior($\alpha$)}, \In{p}{nat}, \In{a}{$\alpha$}}{itColaMin($alpha$)}
	[$c$ $\igobs$ $c_0$]
	{$c$ $\igobs$ encolar($p$,$c_0$) $\wedge$ $res$ $\igobs$ CrearIt(ColaASecu($c_0$), $a$) $\wedge$ alias(SecuSuby(res) = ColaASecu(c))}
	[O(log($\vert$c$\vert$)) + $copy$($a$)]
	[Agrega el elemento $a$ de tipo $\alpha$ con prioridad $p$ a la cola]
	[Se agrega el elemento por copia]

	~

%	\InterfazFuncion{Eliminar}{\Inout{c}{colaMinPrior($\alpha$), \In{i}{nat}}}{}
%	[$\neg$vacía?($c$) $\land$ $c$ $\igobs$ $c_0$]
%	{$c$ $\igobs$ Alias(EsPermutacion(deColaASecu($c$)}
%	[O(log(tamaño(c)))]
%	[Quita el elemento más prioritario]


%	\InterfazFuncion{• = •}{\In{c}{colaMinPrior($\alpha$)}, \In{c'}{colaMinPrior($\alpha$)}}{bool}
%	[true]
%	{$res$ $\igobs$ ($c$ $\igobs$ $c'$)}
%	[O(min(tamaño($c$), tamaño($c'$)))]
%	[Indica si $c$ es igual $c'$]

\subsection{Representación}

	\subsubsection{Representación de colaMinPrior}

		\begin{Estructura}{colaMinPrior($\alpha$)}[colaMin]
			\- \- \- \- donde \TipoVariable{colaMin} es \TipoVariable{tupla}($proximo$: \TipoVariable{puntero(Nodo)},
			\TipoVariable{$tamaño$: nat})
			
			\- \- \- \- donde \TipoVariable{Nodo} es \TipoVariable{tupla}($prior$: \TipoVariable{Nat}, $elem$: \TipoVariable{$\alpha$}, $padre$: \TipoVariable{puntero(Nodo)}, $izq$: \TipoVariable{puntero(Nodo)}, $der$: \TipoVariable{puntero(Nodo)})
			
%			\- \- \- \- donde \TipoVariable{encolado} es \TipoVariable{tupla}($prior$: nat, $elemCola$: itLista(Nodo))			
%		\end{Estructura}

	\subsubsection{Invariante de Representación (Rehacer con nueva estructura)}

		\renewcommand{\labelenumi}{(\Roman{enumi})}

		\begin{enumerate}
			\item Todos ids de cada nodo en elementos son menos que el largo del vector proximos 
			\item Si ids de nodos en elementos son diferentes, evaluados en la posicion correspondiente de proximos, sus prioridades mantienen la diferencia.  
		\end{enumerate}

	\tadAlinearFunciones{Rep}{estr}
	\tadAlinearAxiomas{Rep(e)}

	\Rep[estr][e]{
		\\($\forall i:$ nat) ($i$ < $longitud(e.proximos)$) $\impluego$
	\\	(($\forall j:$ nat) $j \leqslant i$ $\impluego$ (e.proximos[$j$].prioridad $\leqslant$ e.proximos[$i$].prioridad) $\land$
	\\	(($\forall n:$ nat) $n$ < $longitud(e.proximos)$ $\impluego$ e.proximos[$e.elementos$[$n$]$.id$].$elemCola \rightarrow siguiente.elem$ $\igobs$ $e.elementos$[$n$]$.elem$)
	}\mbox{}

	\subsubsection{Función de Abstracción}

	\tadAlinearFunciones{Abs}{Estr/e}

		\Abs[estr]{colaMinPrior}[e]{cmp}{
			(vacía?($cmp$) $\Leftrightarrow$ $tamano$($e$) $\igobs$ 0) $\land$ \\
			 $\neg$ $vacia?$($cmp$) $\impluego$ \\
		  	 (próximo($cmp$) $\igobs$ próximo($e$) $\land$ \\
			 desencolar($cmp$) $\igobs$ desencolar($e$))}

\subsection{Algoritmos}
	\lstset{style=alg}

\begin{algorithm}[H]{\textbf{iVacía}() $\to$ $res$ : colaMin($\alpha$)}
    	\begin{algorithmic}[1]
			\State $res \gets <NULL, 0>$ \Comment {$\Theta(1)$}
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iVacía?}(\In {c}{colaMin($\alpha$)}) $\to$ $res$ : Bool}
    	\begin{algorithmic}[1]
			\State $res \gets (c.proximo = NULL)$ \Comment {$\Theta(1)$}
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPróximo}(\In {c}{colaMinPrior($\alpha$)}) $\to$ $res$ : $\alpha$}
    	\begin{algorithmic}[1]
			\State $res \gets CrearIt(c).Siguiente \rightarrow elem$ \Comment {$\Theta(1)$}
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iDesencolar}(\Inout {c}{colaMinPrior($\alpha$)})}
    	\begin{algorithmic}[1]
			\State $it \leftarrow CrearIt(c) $ \Comment {$\Theta(1)$}
			\State $A \leftarrow DecimalABinario(c.tamaño) $ \Comment {Convertir un decimal a binario tiene complejidad logaritmica del largo de número $\Theta(log(|c|))$}
			\For{i $\leftarrow$ 1 \TO $tam(A)$ - 1} \Comment {Se empieza desde el segundo elemento porque el iterador ya está parado en el primero que por precondición no está invalidado $\Theta(|A|) = \Theta(log(|c|))$}
				\If{$A[i] = 0$}
					\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}
				\Else
					\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}
				\EndIf
			\EndFor
			\State $swapCola(c.proximo, it.siguiente) $ \Comment {$\Theta(1)$}
			\State $EliminarSiguiente(it) $ \Comment {$\Theta(1)$}
			\If($c.tamaño > 1$)
				\State $siftDown(c) $ \Comment {$\Theta(log(|c|))$}
			\EndIf
			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(|c|))$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iEncolar}(\Inout {c}{colaMinPrior($\alpha$), \In {prioridad}{nat}, \In {a}{$\alpha$}})  $\to$ $res$ : $iter$ }
    	\begin{algorithmic}[1]
			\State $Nodo: nuevo \leftarrow <prioridad, a, NULL, NULL, NULL> $ \Comment {$\Theta(1)$}				
			\State $it \leftarrow CrearIt(c)$ \Comment {$\Theta(1)$}
			\State $A \leftarrow DecimalABinario(c.tamaño + 1) $ \Comment {Convertir un decimal a binario tiene complejidad logaritmica del largo de número, buscamos la posición donde vamos a agregar el nuevo elemento $\Theta(log(|c|))$}			
			\State $i \leftarrow 0$ \Comment {$\Theta(1)$}
									
			\While {i < $tam(A)$ - 1} \Comment {$\Theta(|A|) = \Theta(log(|c|))$}			
				\If{$A[i] = 0$} \Comment {$\Theta(1)$}
					\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}
				\Else
					\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}
				\EndIf			
				\State $i \leftarrow i + 1$ \Comment {$\Theta(1)$}
			\EndWhile
			\If{$A[i] = 0$} \Comment {$\Theta(1)$}
				\State $AgregarSiguienteIzq(it, nuevo)$ \Comment {$\Theta(1)$}
			\Else
				\State $AgregarSiguienteDer(it, nuevo)$ \Comment {$\Theta(1)$}
			\EndIf			

			\State $siftUp(c) $ \Comment {$\Theta(log(|c|))$}

			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(|c|)) + copy(\alpha))$
    	\end{algorithmic}
\end{algorithm}
    	
\begin{algorithm}[H]{\textbf{siftDown}(\Inout {c}{colaMin($\alpha$)})}
    	\begin{algorithmic}[1]
			\State $it \leftarrow CrearIt(c)$ \Comment {$\Theta(1)$}
			\State $swap \leftarrow true$
			\While{$\neg esHoja(it) \wedge swap$} \Comment {Lo máximo que se puede llegar a avanzar es la altura del árbol $\Theta(log(|c|))$}
				\State $swap \leftarrow false$ \Comment {$\Theta(1)$}
				\If{$haySiguienteIzq(it) \wedge haySiguienteDer(it)$} \Comment {$\Theta(1)$}
					\If{$it.siguiente \rightarrow izq \rightarrow prior < it.siguiente \rightarrow der \rightarrow prior$} \Comment {$\Theta(1)$}					
						\If{$it.siguiente \rightarrow izq \rightarrow prior < it.siguiente \rightarrow prior$} \Comment {$\Theta(1)$}
							\State $swapCola(it.siguiente \rightarrow izq, it.siguiente) $ \Comment {$\Theta(1)$}
							\State $swap \leftarrow true$ \Comment {$\Theta(1)$}							
							\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}							
						\EndIf
					\Else
						\If{$it.siguiente \rightarrow der \rightarrow prior < it.siguiente \rightarrow prior$} \Comment {$\Theta(1)$}
							\State $swapCola(it.siguiente \rightarrow der, it.siguiente) $ \Comment {$\Theta(1)$}
							\State $swap \leftarrow true$ \Comment {$\Theta(1)$}							
							\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}							
						\EndIf
					\EndIf
				\Else
					\If{$haySiguienteIzq(it)$} \Comment {$\Theta(1)$}
						\If{$it.siguiente \rightarrow izq \rightarrow prior < it.siguiente \rightarrow prior$} \Comment {$\Theta(1)$}
							\State $swapCola(it.siguiente \rightarrow izq, it.siguiente) $ \Comment {$\Theta(1)$}
							\State $swap \leftarrow true$ \Comment {$\Theta(1)$}							
							\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}							
						\EndIf
					\Else
						\If{$it.siguiente \rightarrow der \rightarrow prior < it.siguiente \rightarrow prior$} \Comment {$\Theta(1)$}
							\State $swapCola(it.siguiente \rightarrow der, it.siguiente) $ \Comment {$\Theta(1)$}
							\State $swap \leftarrow true$ \Comment {$\Theta(1)$}							
							\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}							
						\EndIf
					\EndIf
				\EndIf
			\EndWhile
			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(|c|))$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{siftUp}(\Inout {c}{colaMin($\alpha$)})}
    	\begin{algorithmic}[1]
		\State $it \leftarrow CrearIt(c)$ \Comment {$\Theta(1)$}
		\State $swap \leftarrow true$
		\State $A \leftarrow DecimalABinario(c.tamaño) $ \Comment {Convertir un decimal a binario tiene complejidad logaritmica del largo de número $\Theta(log(|c|))$}
		\For{i $\gets$ 1 \TO $tam(A)$ - 1} \Comment {Se empieza desde el segundo elemento porque el iterador ya está parado en el primero que por precondición no está invalidado, se avanza hasta el último elemento que es el que hay que reacomodar  $\Theta(|A|) = \Theta(log(|c|))$}
			\If{$A[i] = 0$}
				\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}
			\Else
				\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}
			\EndIf
		\EndFor
		
		\While{$tienePadre(it) \wedge swap$}\Comment {Lo máximo que se puede llegar a avanzar es la altura del árbol $\Theta(log(|c|))$}
			\State $swap \rightarrow false$ \Comment {$\Theta(1)$}			
			\If{$it.siguiente \rightarrow prior < it.siguiente \rightarrow padre \rightarrow prior $} \Comment {$\Theta(1)$}
				\State $swapCola(it.siguiente \rightarrow padre, it.siguiente) $ \Comment {$\Theta(1)$}
				\State $swap \rightarrow true$ \Comment {$\Theta(1)$}
				\State $Retroceder(it) $ \Comment {$\Theta(1)$}
			\EndIf			
		\EndWhile
		\medskip
		\Statex \underline{Complejidad:} $\Theta(log(|c|))$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{swapCola}{(\Inout {p}{puntero(Nodo)}, \Inout {q}{puntero(Nodo)}})}
   	\begin{algorithmic}[1]
			\State $Nodo: aux \gets (*p) $ \Comment {$\Theta(Copy(\alpha))$}
			\State $p \rightarrow padre \gets q \rightarrow padre $ \Comment {$\Theta(1)$}
			\State $p \rightarrow izq \gets q \rightarrow izq $ \Comment {$\Theta(1)$}
			\State $p \rightarrow der \gets q \rightarrow der $ \Comment {$\Theta(1)$}
			
			\State $q \rightarrow padre \gets aux.padre $ \Comment {$\Theta(1)$}
			\State $q \rightarrow izq \gets aux.izq $ \Comment {$\Theta(1)$}
			\State $q \rightarrow der \gets aux.der $ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(Copy(\alpha))$
   	\end{algorithmic}
\end{algorithm}    	
    	
%%	\begin{lstlisting}[mathescape]
%%	'\alg{• = •}{\In{c_0}{colaMinPrior($\alpha$)}, \In{c_1}{colaMinPrior($\alpha$)}}{bool}'
%%	res $\leftarrow$ $c_0$ = $c_1$ '\ote{min(tamano($c_0$), tamano($c_1$))}'
%%	'\ofi{O(min(tamano(c_0), tamano(c_1)))}'
%%\end{lstlisting}