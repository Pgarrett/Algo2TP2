\section{Módulo Cola de mínima prioridad($\alpha$)}

\subsection{Especificación}

	\begin{tad}{\tadNombre{Cola de mínima prioridad($\alpha$)}}
	\tadIgualdadObservacional{c}{c'}{colaMinPrior($\alpha$)}{vacía?($c$) $\igobs$ vacía?($c'$) $\yluego$ \\
							($\neg$vacía?($c$) $\impluego$ (próximo($c$) $\igobs$ próximo($c'$) $\land$ \\
							\phantom{($\neg$vacía?($c$) $\impluego$ (}desencolar($c$) $\igobs$ desencolar($c'$))}

	\tadParametrosFormales{
		\tadEncabezadoInline{géneros}{$\alpha$}\\
		\tadEncabezadoInline{operaciones}{
			\tadOperacionInline{\argumento $<$ \argumento}{$\alpha$, $\alpha$}{bool} 
		}
	}

	\tadGeneros{colaMinPrior($\alpha$)}
	\tadExporta{colaMinPrior($\alpha$), generadores, observadores}
	\tadUsa{\tadNombre{Bool}}

	\tadAlinearFunciones{desencolar}{$\alpha$,colaMinPrior($\alpha$)}

	\tadObservadores
	\tadOperacion{vacía?}{colaMinPrior($\alpha$)}{bool}{}
	\tadOperacion{próximo}{colaMinPrior($\alpha$)/c}{$\alpha$}{$\neg$ vacía?($c$)}
	\tadOperacion{desencolar}{colaMinPrior($\alpha$)/c}{colaMinPrior($\alpha$)}{$\neg$ vacía?($c$)}

	\tadGeneradores
	\tadOperacion{vacía}{}{colaMinPrior($\alpha$)}{}
	\tadOperacion{encolar}{$\alpha$,colaMinPrior($\alpha$)}{colaMinPrior($\alpha$)}{}

	\tadOtrasOperaciones
	\tadOperacion{tamaño}{colaMinPrior($\alpha$)}{nat}{}

	\tadAxiomas[\paratodo{colaMinPrior($\alpha$)}{c}, \paratodo{$\alpha$}{e}]
	\tadAlinearAxiomas{desencolar(encolar($e$, $c$))}{}

	\tadAxioma{vacía?(vacía)}{true}
	\tadAxioma{vacía?(encolar($e$, $c$))}{false}

	\tadAxioma{próximo(encolar($e$, $c$))}{\IF vacía?($c$) $\oluego$\ proximo($c$) $> e$ THEN $e$ ELSE próximo($c$) FI}

	\tadAxioma{desencolar(encolar($e$, $c$))}{\IF vacía?($c$) $\oluego$\ proximo($c$) $> e$ THEN $c$ ELSE encolar($e$, desencolar($c$)) FI}

	\end{tad}

\subsection{Interfaz}
	\tadParametrosFormales{
		\tadEncabezadoInline{géneros}{$\alpha$}
	}

	\textbf{se explica con}: \tadNombre{Cola de mínima prioridad(nat)}.

	\textbf{géneros}: \TipoVariable{colaMin($\alpha$)}.

\subsubsection{Operaciones básicas de ColaMinPrior}

	\InterfazFuncion{Vacía}{}{colaMin($\alpha$)}
	[true]
	{$res$ $\igobs$ vacía}
	[O(1)]
	[Crea una cola de prioridad vacía]

	\InterfazFuncion{Vacía?}{\In{c}{colaMin($\alpha$)}}{bool}
	[true]
	{$res$ $\igobs$ vacía?(c)}
	[O(1)]
	[Devuelve \TipoVariable{true} si y sólo si la cola está vacía]

	\InterfazFuncion{Próximo}{\In{c}{colaMin($\alpha$)}}{$\alpha$}
	[$\neg$vacía?($c$)]
	{alias($res$ $\igobs$ próximo($c$))}
	[O(1)]
	[Devuelve el próximo elemento a desencolar]
	[$res$ es modificable si y sólo si $c$ es modificable]

	\InterfazFuncion{Desencolar}{\Inout{c}{colaMin($\alpha$)}}{}
	[$\neg$vacía?($c$) $\land$ $c$ $\igobs$ $c_0$]
	{$c$ $\igobs$ desencolar($c_0$)}
	[O(log(tamaño(c)))]
	[Quita el elemento más prioritario]

	\InterfazFuncion{Encolar}{\Inout{c}{colaMinPrior($\alpha$)}, \In{p}{nat}, \In{a}{$\alpha$}}{itColaMin($alpha$)}
	[$c$ $\igobs$ $c_0$]
	{$c$ $\igobs$ encolar($p$,$c_0$) $\wedge$ $res$ $\igobs$ CrearIt(ColaASecu($c_0$), $a$) $\wedge$ alias(SecuSuby(res) = ColaASecu(c))}
	[O(log($\vert$c$\vert$)) + $copy$($a$)]
	[Agrega el elemento $a$ de tipo $\alpha$ con prioridad $p$ a la cola]
	[Se agrega el elemento por copia]

%	\InterfazFuncion{Eliminar}{\Inout{c}{colaMinPrior($\alpha$), \In{i}{nat}}}{}
%	[$\neg$vacía?($c$) $\land$ $c$ $\igobs$ $c_0$]
%	{$c$ $\igobs$ Alias(EsPermutacion(deColaASecu($c$)}
%	[O(log(tamaño(c)))]
%	[Quita el elemento más prioritario]


%	\InterfazFuncion{• = •}{\In{c}{colaMinPrior($\alpha$)}, \In{c'}{colaMinPrior($\alpha$)}}{bool}
%	[true]
%	{$res$ $\igobs$ ($c$ $\igobs$ $c'$)}
%	[O(min(tamaño($c$), tamaño($c'$)))]
%	[Indica si $c$ es igual $c'$]

\subsubsection{Operaciones del Iterador}

	\InterfazFuncion{CrearIt}{\In{c}{ColaMinPrior($\alpha$)}}{itColaMin($alpha$)}
	[$true$]
	{Alias(EsPermutacion(SecuSuby($res$),c))}
	[$\Theta(1)$]
	[Crea un iterador de Cola Mínima de Prioridad($\alpha$)]
	[El iterador se invalida si y solo si se elimina el elemento siguiente del iterador]

	\InterfazFuncion{HaySiguiente?}{\In{it}{itColaMin($\alpha$)}}{bool}
	[$true$]
	{$res$ $\igobs$ haySiguiente?($it$))}
	[$\Theta(1)$]
	[Devuelve true si y solo si en el iterador todavía quedan elementos para avanzar]

	\InterfazFuncion{HaySiguienteIzq?}{\In{it}{itColaMin($\alpha$)}}{bool}
	[haySiguiente?($it$)]
	{$res$ $\igobs$ haySiguienteIzq?($it$))}
	[$\Theta(1)$]
	[Devuelve true si y solo si en el iterador todavía quedan elementos para avanzar a la izquierda]

	\InterfazFuncion{HaySiguienteDer?}{\In{it}{itColaMin($\alpha$)}}{bool}
	[haySiguiente?($it$)]
	{$res$ $\igobs$ haySiguienteDer?($it$))}
	[$\Theta(1)$]
	[Devuelve true si y solo si en el iterador todavía quedan elementos para avanzar a la derecha]	

	\InterfazFuncion{Siguiente}{\In{it}{itColaMin($\alpha$)}}{$\alpha$}
	[haySiguiente?($it$)]
	{Alias($res$ $\igobs$ Siguiente($it$))}
	[$\Theta(1)$]
	[Devuelve el elemento de la siguiente posición del iterador]
	[res es modificable si y solo si it es modificable]

	\InterfazFuncion{AvanzarIzq}{\Inout{it}{itColaMin($\alpha$)}}{}
	[$it$ $\igobs$ $it_0$ $\wedge$ haySiguienteIzq?($c$)]
	{$it$ $\igobs$ avanzarIzq($it_0$))}
	[$\Theta(1)$]
	[Avanza el iterador a la posición izquierda siguiente]

	\InterfazFuncion{AvanzarDer}{\Inout{it}{itColaMin($\alpha$)}}{}
	[$it$ $\igobs$ $it_0$ $\wedge$ haySiguienteDer?($it$)]
	{$it$ $\igobs$ avanzarDer($it_0$))}
	[$\Theta(1)$]
	[Avanza el iterador a la posición derecha siguiente]

	\InterfazFuncion{EliminarSiguiente}{\Inout{it}{itColaMin($\alpha$)}}{}
	[$it$ $\igobs$ $it_0$ $\wedge$ haySiguiente?($it$) $\yluego$ $\neg$haySiguienteDer?($it$) $\wedge$ $\neg$haySiguienteIzq?($it$)]
	{$it$ $\igobs$ EliminarSiguiente($it_0$))}
	[$\Theta(1)$]
	[Elimina de la cola el valor que se encuentra en la posición siguiente del iterador. Tiene que ser hoja]
	
	\InterfazFuncion{AgregarComoSiguienteIzq}{\Inout{it}{itColaMin($\alpha$)}, \In{a}{$\alpha$}}{}
	[$it$ $\igobs$ $it_0$ $\wedge$ $\neg$haySiguienteDer?($it$) $\wedge$ $\neg$haySiguienteIzq?($it$)]
	{$it$ $\igobs$ AgregarComoSiguienteIzq($it_0$))}
	[O($copy(a)$)]
	[agrega el elemento a a la cola de prioridad, a la izquierda siguiente del iterador, dejando
al iterador posicionado de forma tal que al llamar a Siguiente se obtenga a.]

	\InterfazFuncion{AgregarComoSiguienteDer}{\Inout{it}{itColaMin($\alpha$)}, \In{a}{$\alpha$}}{}
	[$it$ $\igobs$ $it_0$ $\wedge$ $\neg$haySiguienteDer?($it$)]
	{$it$ $\igobs$ AgregarComoSiguienteDer($it_0$))}
	[O($copy(a)$)]
	[agrega el elemento a a la cola de prioridad, a la derecha siguiente del iterador, dejando
al iterador posicionado de forma tal que al llamar a Siguiente se obtenga a.]

\subsection{Representación}

	\subsubsection{Representación de ColaMinPrior($\alpha$)}

		\begin{Estructura}{ColaMinPrior($\alpha$)}[colaMin]
			\- \- \- \- donde \TipoVariable{colaMin} es \TipoVariable{tupla}($proximo$: \TipoVariable{puntero(nodo)},
			\TipoVariable{$tamano$: nat})
			
			\- \- \- \- donde \TipoVariable{nodo} es \TipoVariable{tupla}($prior$: \TipoVariable{Nat}, $elem$: \TipoVariable{$\alpha$}, $padre$: \TipoVariable{puntero(nodo)}, $izq$: \TipoVariable{puntero(nodo)}, $der$: \TipoVariable{puntero(nodo)})
			
%			\- \- \- \- donde \TipoVariable{encolado} es \TipoVariable{tupla}($prior$: nat, $elemCola$: itLista(Nodo))			
		\end{Estructura}

	\subsubsection{Invariante de Representación (Rehacer con nueva estructura)}

		\renewcommand{\labelenumi}{(\Roman{enumi})}

		\begin{enumerate}
			\item Todos ids de cada nodo en elementos son menos que el largo del vector proximos 
			\item Si ids de nodos en elementos son diferentes, evaluados en la posicion correspondiente de proximos, sus prioridades mantienen la diferencia.  
		\end{enumerate}

	\tadAlinearFunciones{Rep}{estr}
	\tadAlinearAxiomas{Rep(e)}

	\Rep[estr][e]{
		\\($\forall i:$ nat) ($i$ < $longitud(e.proximos)$) $\impluego$
	\\	(($\forall j:$ nat) $j \leqslant i$ $\impluego$ (e.proximos[$j$].prioridad $\leqslant$ e.proximos[$i$].prioridad) $\land$
	\\	(($\forall n:$ nat) $n$ < $longitud(e.proximos)$ $\impluego$ e.proximos[$e.elementos$[$n$]$.id$].$elemCola \rightarrow siguiente.elem$ $\igobs$ $e.elementos$[$n$]$.elem$)
	}\mbox{}

	\subsubsection{Función de Abstracción}

	\tadAlinearFunciones{Abs}{Estr/e}

		\Abs[estr]{colaMinPrior}[e]{cmp}{
			(vacía?($cmp$) $\Leftrightarrow$ $tamano$($e$) $\igobs$ 0) $\land$ \\
			 $\neg$ $vacia?$($cmp$) $\impluego$ \\
		  	 (próximo($cmp$) $\igobs$ próximo($e$) $\land$ \\
			 desencolar($cmp$) $\igobs$ desencolar($e$))}

\subsubsection{Representación del Iterador Cola de Prioridad}

		\begin{Estructura}{ItColaMin($\alpha$)}[iter]
			\- \- \- \- donde \TipoVariable{iter} es \TipoVariable{tupla}($siguiente$: \TipoVariable{puntero(nodo)},
			\TipoVariable{$arbol$: \TipoVariable{puntero(ColaMinPrior($\alpha$))}})

		\subsubsection{Invariante de Representación}

		\renewcommand{\labelenumi}{(\Roman{enumi})}

		%\begin{enumerate}
		%	\item Todos ids de cada nodo en elementos son menos que el largo del vector proximos 
		%	\item Si ids de nodos en elementos son diferentes, evaluados en la posicion correspondiente de proximos, sus prioridades mantienen la diferencia.  
		%\end{enumerate}

	%\tadAlinearFunciones{Rep}{estr}
	%\tadAlinearAxiomas{Rep(e)}

	%\Rep[estr][e]{
%		\\($\forall i:$ nat) ($i$ < $longitud(e.proximos)$) $\impluego$
%	\\	(($\forall j:$ nat) $j \leqslant i$ $\impluego$ (e.proximos[$j$].prioridad $\leqslant$ e.proximos[$i$].prioridad) $\land$
%	\\	(($\forall n:$ nat) $n$ < $longitud(e.proximos)$ $\impluego$ e.proximos[$e.elementos$[$n$]$.id$].$elemCola \rightarrow siguiente.elem$ $\igobs$ $e.elementos$[$n$]$.elem$)
%	}\mbox{}

	\subsubsection{Función de Abstracción}

	\tadAlinearFunciones{Abs}{Estr/e}

%		\Abs[estr]{colaMinPrior}[e]{cmp}{
%			(vacía?($cmp$) $\Leftrightarrow$ $tamano$($e$) $\igobs$ 0) $\land$ \\
%			 $\neg$ $vacia?$($cmp$) $\impluego$ \\
%		  	 (próximo($cmp$) $\igobs$ próximo($e$) $\land$ \\
%			 desencolar($cmp$) $\igobs$ desencolar($e$))}

\subsection{Algoritmos}
	\lstset{style=alg}

\subsubsection{Algoritmos del Modulo}

\begin{algorithm}[H]{\textbf{iVacía}() $\to$ $res$ : colaMin($\alpha$)}
    	\begin{algorithmic}[1]
			\State $res \gets <NULL, 0>$ \Comment {$\Theta(1)$}
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iVacía?}(\In {c}{colaMin($\alpha$)}) $\to$ $res$ : Bool}
    	\begin{algorithmic}[1]
			\State $res \gets (c.proximo = NULL)$ \Comment {$\Theta(1)$}
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPróximo}(\In {c}{colaMinPrior($\alpha$)}) $\to$ $res$ : $\alpha$}
    	\begin{algorithmic}[1]
			\State $res \gets CrearIt(c).Siguiente \rightarrow elem$ \Comment {$\Theta(1)$}
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iDesencolar}(\Inout {c}{colaMinPrior($\alpha$)})}
    	\begin{algorithmic}[1]
			\State $it \leftarrow CrearIt(c) $ \Comment {$\Theta(1)$}
			\State $A \leftarrow DecimalABinario(c.tamaño) $ \Comment {Convertir un decimal a binario tiene complejidad logaritmica del largo de número $\Theta(log(|c|))$}
			\For{i $\leftarrow$ 1 to $tam(A)$ - 1} \Comment {Se empieza desde el segundo elemento porque el iterador ya está parado en el primero que por precondición no está invalidado $\Theta(|A|) = \Theta(log(|c|))$}
				\If{$A[i] = 0$}
					\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}
				\Else
					\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}
				\EndIf
			\EndFor
			\State $swapCola(c.proximo, it.siguiente) $ \Comment {$\Theta(1)$}
			\State $EliminarSiguiente(it) $ \Comment {$\Theta(1)$}
			\If{$c.tamano > 1$}
				\State $siftDown(c) $ \Comment {$\Theta(log(|c|))$}
			\EndIf
			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(|c|))$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iEncolar}(\Inout {c}{colaMinPrior($\alpha$), \In {prioridad}{nat}, \In {a}{$\alpha$}})  $\to$ $res$ : $iter$ }
    	\begin{algorithmic}[1]
			\State $Nodo: nuevo \leftarrow <prioridad, a, NULL, NULL, NULL> $ \Comment {$\Theta(1)$}				
			\State $it \leftarrow CrearIt(c)$ \Comment {$\Theta(1)$}
			\State $A \leftarrow DecimalABinario(c.tamaño + 1) $ \Comment {Convertir un decimal a binario tiene complejidad logaritmica del largo de número, buscamos la posición donde vamos a agregar el nuevo elemento $\Theta(log(|c|))$}			
			\State $i \leftarrow 0$ \Comment {$\Theta(1)$}
									
			\While {i < $tam(A)$ - 1} \Comment {$\Theta(|A|) = \Theta(log(|c|))$}			
				\If{$A[i] = 0$} \Comment {$\Theta(1)$}
					\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}
				\Else
					\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}
				\EndIf			
				\State $i \leftarrow i + 1$ \Comment {$\Theta(1)$}
			\EndWhile
			\If{$A[i] = 0$} \Comment {$\Theta(1)$}
				\State $AgregarSiguienteIzq(it, nuevo)$ \Comment {$\Theta(1)$}
			\Else
				\State $AgregarSiguienteDer(it, nuevo)$ \Comment {$\Theta(1)$}
			\EndIf			

			\State $siftUp(c) $ \Comment {$\Theta(log(|c|))$}

			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(|c|)) + copy(\alpha))$
    	\end{algorithmic}
\end{algorithm}
    	
\begin{algorithm}[H]{\textbf{siftDown}(\Inout {c}{colaMin($\alpha$)})}
    	\begin{algorithmic}[1]
			\State $it \leftarrow CrearIt(c)$ \Comment {$\Theta(1)$}
			\State $swap \leftarrow true$
			\While{$\neg esHoja(it) \wedge swap$} \Comment {Lo máximo que se puede llegar a avanzar es la altura del árbol $\Theta(log(|c|))$}
				\State $swap \leftarrow false$ \Comment {$\Theta(1)$}
				\If{$haySiguienteIzq(it) \wedge haySiguienteDer(it)$} \Comment {$\Theta(1)$}
					\If{$it.siguiente \rightarrow izq \rightarrow prior < it.siguiente \rightarrow der \rightarrow prior$} \Comment {$\Theta(1)$}					
						\If{$it.siguiente \rightarrow izq \rightarrow prior < it.siguiente \rightarrow prior$} \Comment {$\Theta(1)$}
							\State $swapCola(it.siguiente \rightarrow izq, it.siguiente) $ \Comment {$\Theta(1)$}
							\State $swap \leftarrow true$ \Comment {$\Theta(1)$}							
							\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}							
						\EndIf
					\Else
						\If{$it.siguiente \rightarrow der \rightarrow prior < it.siguiente \rightarrow prior$} \Comment {$\Theta(1)$}
							\State $swapCola(it.siguiente \rightarrow der, it.siguiente) $ \Comment {$\Theta(1)$}
							\State $swap \leftarrow true$ \Comment {$\Theta(1)$}							
							\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}							
						\EndIf
					\EndIf
				\Else
					\If{$haySiguienteIzq(it)$} \Comment {$\Theta(1)$}
						\If{$it.siguiente \rightarrow izq \rightarrow prior < it.siguiente \rightarrow prior$} \Comment {$\Theta(1)$}
							\State $swapCola(it.siguiente \rightarrow izq, it.siguiente) $ \Comment {$\Theta(1)$}
							\State $swap \leftarrow true$ \Comment {$\Theta(1)$}							
							\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}							
						\EndIf
					\Else
						\If{$it.siguiente \rightarrow der \rightarrow prior < it.siguiente \rightarrow prior$} \Comment {$\Theta(1)$}
							\State $swapCola(it.siguiente \rightarrow der, it.siguiente) $ \Comment {$\Theta(1)$}
							\State $swap \leftarrow true$ \Comment {$\Theta(1)$}							
							\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}							
						\EndIf
					\EndIf
				\EndIf
			\EndWhile
			\medskip
			\Statex \underline{Complejidad:} $\Theta(log(|c|))$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{siftUp}(\Inout {c}{colaMin($\alpha$)})}
    	\begin{algorithmic}[1]
		\State $it \leftarrow CrearIt(c)$ \Comment {$\Theta(1)$}
		\State $swap \leftarrow true$
		\State $A \leftarrow DecimalABinario(c.tamaño) $ \Comment {Convertir un decimal a binario tiene complejidad logaritmica del largo de número $\Theta(log(|c|))$}
		\For{i $\gets$ 1 to $tam(A)$ - 1} \Comment {Se empieza desde el segundo elemento porque el iterador ya está parado en el primero que por precondición no está invalidado, se avanza hasta el último elemento que es el que hay que reacomodar  $\Theta(|A|) = \Theta(log(|c|))$}
			\If{$A[i] = 0$}
				\State $AvanzarIzq(it) $ \Comment {$\Theta(1)$}
			\Else
				\State $AvanzarDer(it) $ \Comment {$\Theta(1)$}
			\EndIf
		\EndFor
		
		\While{$tienePadre(it) \wedge swap$}\Comment {Lo máximo que se puede llegar a avanzar es la altura del árbol $\Theta(log(|c|))$}
			\State $swap \rightarrow false$ \Comment {$\Theta(1)$}			
			\If{$it.siguiente \rightarrow prior < it.siguiente \rightarrow padre \rightarrow prior $} \Comment {$\Theta(1)$}
				\State $swapCola(it.siguiente \rightarrow padre, it.siguiente) $ \Comment {$\Theta(1)$}
				\State $swap \rightarrow true$ \Comment {$\Theta(1)$}
				\State $Retroceder(it) $ \Comment {$\Theta(1)$}
			\EndIf			
		\EndWhile
		\medskip
		\Statex \underline{Complejidad:} $\Theta(log(|c|))$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{swapCola}{(\Inout {p}{puntero(Nodo)}, \Inout {q}{puntero(Nodo)}})}
   	\begin{algorithmic}[1]
			\State $Nodo: aux \gets (*p) $ \Comment {$\Theta(Copy(\alpha))$}
			\State $p \rightarrow padre \gets q \rightarrow padre $ \Comment {$\Theta(1)$}
			\State $p \rightarrow izq \gets q \rightarrow izq $ \Comment {$\Theta(1)$}
			\State $p \rightarrow der \gets q \rightarrow der $ \Comment {$\Theta(1)$}
			
			\State $q \rightarrow padre \gets aux.padre $ \Comment {$\Theta(1)$}
			\State $q \rightarrow izq \gets aux.izq $ \Comment {$\Theta(1)$}
			\State $q \rightarrow der \gets aux.der $ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(Copy(\alpha))$
   	\end{algorithmic}
\end{algorithm}    	
    	
\begin{algorithm}[H]{\textbf{DecimalABinario}{(\In {d}{nat}}) $\to$ $res$ : arreglo(nat)}
   	\begin{algorithmic}[1]
		\State $lista(\alpha): temp \gets Vacia() $ \Comment {$\Theta(1)$}
		\While{$d > 1$}\Comment {Lo máximo que se puede llegar a iterar es log(d) $\Theta(log(d))$}
			\State $AgregarAdelante(temp, d mod 2)$ \Comment {$\Theta(1)$}			
			\State $d \gets d/2$ \Comment {División entera $\Theta(1)$}			
		\EndWhile
		\State $AgregarAdelante(temp, d)$ \Comment {$\Theta(1)$}
		\State $it \gets CrearIt(temp)$ \Comment {$\Theta(1)$}					
		\State $nat i \gets 0$ \Comment {$\Theta(1)$}
		\State $arreglo(nat) bin \gets CrearArreglo(Longitud(temp)) $ \Comment {$\Theta(1)$}		
		\While{$HaySiguiente(it)$}\Comment {El largo de la lista es log(d) $\Theta(|temp|) = \Theta(log(d))$}
			\State $bin[i] \gets Siguiente(it)$ \Comment {$\Theta(1)$}			
			\State $i \gets i+1$ \Comment {$\Theta(1)$}			
		\EndWhile
		\State $res \gets bin$ \Comment {$\Theta(1)$}
		\Statex \underline{Complejidad:} $\Theta(log(d))$
   	\end{algorithmic}
\end{algorithm}    
%%	\begin{lstlisting}[mathescape]
%%	'\alg{• = •}{\In{c_0}{colaMinPrior($\alpha$)}, \In{c_1}{colaMinPrior($\alpha$)}}{bool}'
%%	res $\leftarrow$ $c_0$ = $c_1$ '\ote{min(tamano($c_0$), tamano($c_1$))}'
%%	'\ofi{O(min(tamano(c_0), tamano(c_1)))}'
%%\end{lstlisting}

\subsubsection{Algoritmos del Iterador}

\begin{algorithm}[H]{\textbf{CrearIt}(\In{c}{ColaMinPrior($\alpha$)}) $\to$ $res$ : itColaMin($\alpha$)}
   	\begin{algorithmic}[1]
			\State $res \gets <NULL, c>$ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}    	

\begin{algorithm}[H]{\textbf{HaySiguiente?}(\In{it}{itColaMin($\alpha$)}) $\to$ $res$ : bool}
   	\begin{algorithmic}[1]
			\State $res \gets it.siguiente \neq NULL $ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}  

\begin{algorithm}[H]{\textbf{HaySiguienteIzq?}(\In{it}{itColaMin($\alpha$)}) $\to$ $res$ : bool}
   	\begin{algorithmic}[1]
			\State $res \gets it.siguiente \rightarrow izq \neq NULL $ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}  

\begin{algorithm}[H]{\textbf{HaySiguienteDer?}(\In{it}{itColaMin($\alpha$)}) $\to$ $res$ : bool}
   	\begin{algorithmic}[1]
			\State $res \gets it.siguiente \rightarrow der \neq NULL $ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{Siguiente?}(\In{it}{itColaMin($\alpha$)}) $\to$ $res$ : $\alpha$}
   	\begin{algorithmic}[1]
			\State $res \gets (it.siguiente \rightarrow elem) $ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{AvanzarIzq}(\Inout{it}{itColaMin($\alpha$)})}
   	\begin{algorithmic}[1]
			\State $it.siguiente \gets (it.siguiente \rightarrow izq) $ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{AvanzarDer}(\Inout{it}{itColaMin($\alpha$)})}
   	\begin{algorithmic}[1]
			\State $it.siguiente \gets (it.siguiente \rightarrow der) $ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{EliminarSiguiente}(\Inout{it}{itColaMin($\alpha$)})}
   	\begin{algorithmic}[1]
			\State $it.siguiente \gets NULL $ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{AgregarComoSiguienteIzq}(\Inout{it}{itColaMin($\alpha$)}, \In{a}{$\alpha$})}
   	\begin{algorithmic}[1]
			\State $(it.siguiente \rightarrow izq) \gets a$ \Comment {$\Theta(1)$}
			\State $AvanzarIzq(it)$ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{AgregarComoSiguienteDer}(\Inout{it}{itColaMin($\alpha$)}, \In{a}{$\alpha$})}
   	\begin{algorithmic}[1]
			\State $(it.siguiente \rightarrow der) \gets a$ \Comment {$\Theta(1)$}
			\State $AvanzarDer(it)$ \Comment {$\Theta(1)$}
			\Statex \underline{Complejidad:} $\Theta(1)$
   	\end{algorithmic}
\end{algorithm}