\section{Modulo Mapa}

%TODO descripcion

\begin{Interfaz}

  \textbf{usa}: \tadNombre{Nat, Bool, Coordenada, Conj($\alpha$)}.

  \textbf{se explica con}: \tadNombre{Mapa}.

  \textbf{generos}: \TipoVariable{map}.

  \InterfazFuncion{CrearMapa}{}{Mapa}%
  [true]
  {$res \igobs crearMapa()$}
  [$O(1)$]
  [Crea un nuevo mapa]

  \InterfazFuncion{AgregarCoordenada}{\Inout{m}{map}, \In{c}{coor}}{itConj(coor)}
  [$m \igobs m_0$]
  {$m \igobs agregarCoor(c, m_0)$}
  [$\Theta\left(\displaystyle\sum_{c' \in coordendas(m)}equal(c,c')\right)$]
  [Agrega una coordenada al mapa y devuelve el iterador a la coordenada agregada. Su complejidad es la de agregar un elemento al conjunto lineal.]

  \InterfazFuncion{Coordenadas}{\In{m}{map}}{itConj(coor)}
  [true]
  {$res \igobs coordenadas(m)$}
  [$O(1)$]
  [Devuelve un iterador al conjunto de coordenadas del mapa]
  
  \InterfazFuncion{PosExistente}{\In{c}{coor}, \In{m}{map}}{Bool}
  [true]
  {$res \igobs posExistente(c, m)$}
  [$O(1)$]
  [Devuelve verdadero si la coordenada esta en el conjunto de coordenadas del mapa]
  
  \InterfazFuncion{HayCamino}{\In{c1}{coor}, \In{c2}{coor}, \In{m}{map}}{Bool}
  [$c1 \in coordenadas(m) \land c2 \in coordenadas(m)$]
  {$res \igobs hayCamino(c1, c2, m)$}
  [$\Theta(1)$]
  [Devuelve verdadero si existe un camino entre ambas coordenadas]
    
\end{Interfaz}

\begin{Representacion}
\subsubsection{Representación de Mapa}
	\begin{Estructura}{Mapa}[estr]
		\begin{Tupla}[estr]
			\tupItem{coordenadas}{ConjLineal}%
			\tupItem{ancho}{Nat}
			\tupItem{secciones}{DiccMat($coor$, $Nat$)}
		\end{Tupla}
	\end{Estructura}
	
\subsubsection{Invariante de Representación}
	\begin{enumerate}
		\item El ancho del mapa es igual al maximo del primer elemento de las coordenadas
	\end{enumerate}
	\Rep[estr][e]{(e.ancho = Max($campo_1$(coordenadas)) $\wedge$ ($\forall c: coor$) c $\in$ e.coordenadas $\impluego$ def?(c,e.secciones)}

\subsubsection{Funci\'on de Abstracci\'on}
	\AbsFc[estr]{mapa}[e]{($\forall m : Mapa$) e.coordenadas = coordenadas(m)}

\end{Representacion}

\begin{Algoritmos}

\medskip
	
 \Titulo{Algoritmos del modulo}
  	\medskip
  
\begin{algorithm}[H]{\textbf{iCrearMapa}() $\to$ $res$ : Mapa}
    	\begin{algorithmic}[1]
			\State $res.coordenadas \gets Vacio()$ \Comment{La complejidad es la de crear el Conjunto Lineal vacio $\Theta(1)$}
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iAgregarCoordenada}(\Inout {m}{map}, \In {c}{coor}) $\to$ $res$ : itConj(coor)}
    	\begin{algorithmic}[1]
            \State $ largo \gets Largo(m)  $ \Comment $\Theta( ??)$
            \State $ ancho \gets Ancho(m)$ \Comment $\Theta( ?? )$
            \State $ m.secciones \gets CrearArreglo(largo * ancho)$ \Comment $\Theta(largo * ancho)$
			\State $res \gets Agregar(m.coordenadas, c)$ \Comment $\Theta\left(\displaystyle\sum_{c' \in coordendas(m)}equal(c,c')\right)$
            \State $ seccion \gets 0 $ \Comment $\Theta(1)$
            \State $ itCoor \gets CrearIt(m.coordenadas)$ \Comment $\Theta(1)$
			 
            \While{$HaySiguiente(itCoor)$}			\Comment $\Theta( ?? )$
                \State $coord \gets Siguiente(itCoor)  $ \Comment $\Theta(1)$
			 	\State $Avanzar(it)$		\Comment $\Theta(1)$
                \If{$\lnot(Definido?(m.secciones, coord))$} \Comment $\Theta(1)$
                    \State $ DefinirSeccion(m, coord, seccion) $ \Comment $\Theta( ?? )$ 
                    \State $ seccion \gets seccion + 1 $ \Comment $\Theta(1)$
                \EndIf
			\EndWhile

			\medskip
			\Statex \underline{Complejidad:} $\Theta\left(\displaystyle\sum_{c' \in coordendas(m)}equal(c,c')\right)$
			\Statex \underline{Justificación:} La complejidad es la de agregar un elemento al conjunto lineal.
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iDefinirSeccion}(\Inout {m}{map}, \In {c}{coor}, \In {i}{nat})}
    	\begin{algorithmic}[1]
            \If{$\lnot(Definido?(m.secciones, c)) $\land$ PosExistente(c, m)$} \Comment $\Theta(Pos existente (no es 1) ???)$
                \State $  $ \Comment $\Theta()$
                \State $Definir(m.secciones, c, i)$ \Comment $\Theta(1)$
                \State $DefinirSeccion(m, CoordenadaArriba(c), i)$ \Comment $\Theta(???)$
                \State $DefinirSeccion(m, CoordenadaALaDerecha(c), i)$ \Comment $\Theta(???)$
                \If{$Latitud(c) > 0$} \Comment $\Theta(1)$
                    \State $DefinirSeccion(m, CoordenadaAbajo(c), i)$ \Comment $\Theta(???)$
                \EndIf
                \If{$Longitud(c) > 0$} \Comment $\Theta(1)$
                    \State $DefinirSeccion(m, CoordenadaALaIzquierda(c), i)$ \Comment $\Theta(???)$
                \EndIf
            \EndIf

			\medskip
			\Statex \underline{Complejidad:} $\Theta( ?? )$
			\Statex \underline{Justificación:}
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iCoordenadas}(\In {m}{map}) $\to$ $res$ : itConj(coor)}
    	\begin{algorithmic}[1]
			\State $res \gets CrearIt(m.coordenadas)$ \Comment {La complejidad es la de crear un iterador a un conjunto lineal $\Theta(1)$}
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iPosExistente}(\In{c}{coor}, \In{m}{map}) $\to$ $res$ : Bool}
    	\begin{algorithmic}[1]
			\State $res \gets pertenece?(m.coordenadas, c)$ \Comment  $\Theta\left(\displaystyle\sum_{c' \in coordendas(m)}equal(c,c')\right)$
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta\left(\displaystyle\sum_{c' \in coordendas(m)}equal(c,c')\right)$
			\Statex \underline{Justificación:} La complejidad es la fijarse que un elemento pertenezca al conjunto lineal.
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iHayCamino}(\In{c1}{coor}, \In{c2}{coor}, \In{m}{map}) $\to$ $res$ : $bool$}
    	\begin{algorithmic}[1]
			\State $res \gets (Definido?(m.secciones, c1) $\land$ Definido?(m.secciones, c2)) $\land_L$ (Significado(m.secciones, c1) = Significado(m.secciones, c2))$ \Comment $\Theta(1)$
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iAncho}(\In{m}{map}) $\to$ $res$ : nat}
    	\begin{algorithmic}[1]
			\State $res \gets m.ancho$ \Comment $\Theta(1)$
			
			\medskip
			\Statex \underline{Complejidad:} $\Theta(1)$
    	\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]{\textbf{iLargo}(\In{m}{map}) $\to$ $res$ : nat}
    	\begin{algorithmic}[1]
			\State $it \gets CrearIt(m.coordenadas)$ \Comment $\Theta(1)$
			\State $max \gets 0$ \Comment $\Theta(1)$
			\While $HaySiguiente(it)$ \Comment $\O(\sharp m.coordenadas)$
				\If( $max < \Pi_2(it \rightarrow siguiente)$) \Comment $\Theta(1)$
					\State $max \gets \Pi_2 (it \rightarrow siguiente)$ \Comment $\Theta(1)$					
				\EndIf
				\State $Avanzar(it)$ \Comment $\Theta(1)$				
			\EndWhile
			\medskip
			\Statex \underline{Complejidad:} $\Theta(\sharp m.coordenadas)$
    	\end{algorithmic}
\end{algorithm}

\end{Algoritmos}
